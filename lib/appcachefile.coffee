module.exports = (grunt) ->
  crypto = require('crypto')
  path = require('path')
  md5 = null

  updateHash = (filePath) ->
    grunt.verbose.writeln('Hashing ' + filePath)
    data = grunt.file.read(filePath)
    md5.update(data, 'binary')

  class AppCacheFile
    constructor: (@src, @dest, options) ->
      @output = 'CACHE MANIFEST'
      @verbose = options.verbose
      @timestamp = options.timestamp
      @revision = options.revision
      @cache = options.cache
      @process = options.process
      @hash = options.hash
      @master = options.master
      @basePath = options.basePath

      # if hash options is specified it will be used to calculate
      # a hash of local files that are included in the manifest
      md5 = crypto.createHash('md5') if options.hash

      # Metadata section
      @renderMetadata()

      # Cache section
      @renderCache()

      # Network section
      @renderNetwork()

      # Fallback section
      @renderFallback()

      # Settings section
      @renderSettings()

      # output hash to cache manifest
      @renderHash()

    writeln: (str) ->
      @output += (str || '') + '\n'

    renderMetadata: ->
      @writeln()
      @writeln('# Generated by grunt-manifest HTML5 Cache Manifest Generator') if @verbose
      @writeln('# Time: ' + new Date()) if @timestamp
      @writeln('# Revision: ' + @revision) if @revision

    renderCache: () ->
      @writeln()
      @writeln('CACHE:')

      # add files to explicit cache manually
      if (@cache)
        for item in @cache
          @writeln(encodeURI(item))

      # add files to explicit cache
      if (@src)
        for item in @src
          if (@process)
            @writeln(encodeURI(@process(item)))
          else
            @writeln(encodeURI(item))

          # hash file contents
          if (@hash)
            updateHash(path.join(@basePath, item))

    renderNetwork: ->
      @writeln()
      @writeln('NETWORK:')

      if (@network)
        for item in @network
          @writeln(encodeURI(item))
      else
        # If there's no network section, add a default '*' wildcard
        @writeln('*')

    renderFallback: ->
      if (@fallback)
        @writeln()
        @writeln('FALLBACK:')

        for item in @fallback
          @writeln(encodeURI(item))

    renderSettings: ->
      if (@preferOnline)
        @writeln()
        @writeln('SETTINGS:')
        @writeln('prefer-online')

    renderHash: ->
      if (@hash)
        # hash masters as well
        if (@master)
          # convert form string to array
          @master = [@master] if typeof @master is 'string'

          for item in @master
            updateHash(path.join(@basePath, item))

        @writeln()
        @writeln('# hash: ' + md5.digest("hex"))
